#pragma once

#include <utility>

#include "kimm_path_planner/base/PlannerSettings.h"
#include "kimm_path_planner/base/Primitives.h"

// Base class for all the steering functions
class GNode_base {
 public:
  virtual ~GNode_base() = default;

  /// Cost associated to the best Node selected
  double steer_cost{0};

  /// Number of outgoing edges per node
  int nEdges{0};

  /// Cost per each orientation associated to the node
  double *costs{nullptr};

  /// array of possible orientations
  double *orientations{nullptr};

  /// flag to read orientations from Map
  int READ_OR{0};

  int CHECK_SUCCESSOR{0};

  int goal_x{0};
  int goal_y{0};

  int start_x{0};
  int start_y{0};

  /// X and Y coordinates of the Node
  int x{0}, y{0};

  double x_r{0}, y_r{0};

  /// Flag to indicate if node hase been generated by a steering function
  bool steer{false};

  /// Orientation associated to the best node
  double theta{0};

  bool hasParent{false};

  GNode_base *parent{nullptr};
  GNode_base *child{nullptr};

  inline ompl::base::State *toState() const {
    double unit = global::settings.environment->unit();
    return Point(x_r * unit, y_r * unit).toState(theta);
  }

  // ============================================================================================
  /// line(GNode *successor,GNode *parent_node)
  /// Check if there is a geometric line of sight between the two nodes
  /// ============================================================================================
  static bool line(const GNode_base *parent_node, const GNode_base *successor);

  //  static bool line(double x0, double y0, double y1, double x1);

  // ============================================================================================
  /// bool isblock(double x, double y)
  /// Check if the cell is blocked by an obstacle
  /// ============================================================================================
  static bool isblock(double x, double y, double theta);
};
